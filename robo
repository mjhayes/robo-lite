#!/usr/bin/perl
# vim: expandtab:ts=8

# robo-lite v12
# Written by: Matt Hayes <nobomb@gmail.com>

use strict;
use warnings;

use Config::Tiny;
use Cwd 'abs_path';
use IO::Poll;
use IO::Socket::INET;
use IO::Socket::SSL;
use POSIX qw(strftime);

sub xprint { print strftime("[%H:%M:%S] ", localtime).(shift); }
$|++;

# Get the directory of our executable, so we can append the path to any files,
# enabling us to launch the executable from any directory!
my $ap = abs_path($0);
$ap =~ s/\/[^\/]*$//;

# Write process ID to file
open(FH, ">$ap/robo.pid") or die "Could not write $ap/robo.pid: $!\n";
print FH $$;
close(FH);

# Load servers configuration
xprint "Loading servers.ini: ";
my $servers = Config::Tiny->new();
$servers = Config::Tiny->read($ap.'/servers.ini')
        or die "fail: $!\n";
print "success\n";

# Modules and events structures
my ($mods, $events, $hupd);

# Setup the SIGHUP signal handler, which will reload modules.
$SIG{HUP} = sub {
        unloadmods();
        loadmods();
        $hupd = 1;
};

# Load modules
unloadmods();
loadmods();

# Connect to servers
my $conns = { };
my $poll = IO::Poll->new();
foreach (keys(%{$servers})) {
        tryconn($_);
}

# Poll loop!
while (1) {
        # We want poll to return after 10 seconds so we can check timeouts in
        # case we disconnect from somewhere or everywhere
        my $n = $poll->poll(10);
        if ($n == -1) {
                if (defined($hupd)) {
                        $hupd = undef;
                        next;
                }
                die "Poll failed!\n";
        }

        foreach (keys(%{$conns})) {
                # This connection is not currently enabled.  This means that
                # the initial connection probably failed, so we do need to
                # attempt connection again some time soon.
                if ($conns->{$_}->{enabled} == 0) {
                        if (time() - $conns->{$_}->{lastevent} >
                            $servers->{$_}->{reconnect}) {
                                tryconn($_);
                        }
                        next;
                # This motha timed out.  Lets disconnect and then attempt a
                # reconnection.
                } elsif (time() - $conns->{$_}->{lastevent} >
                         $servers->{$_}->{timeout}) {
                        delconn($_, $conns->{$_}->{sock});
                        tryconn($_);
                        next;
                }

                # Nothing happened on any of our FDs
                next if ($n == 0);

                my $s = $conns->{$_}->{sock};

                # Socket isn't valid
                next if (!$s);

                my $ev = $poll->events($s);

                # Ready to read
                if ($ev & POLLIN) {
                        my $buf = <$s>;

                        next if (!$buf);
                        event($_, $s, $buf);
                }
                # Ready to write (we get this when a connection succeeds)
                if ($ev & POLLOUT) {
                        $poll->mask($s, POLLIN);
                        auth($_, $s);
                }
                # Error (usually bad connect)
                if ($ev & (POLLHUP | POLLERR)) {
                        xprint "$_: POLLHUP|POLLERR\n";
                        delconn($_, $s);
                        next;
                }
        }
}

# Authenticate
sub auth {
        my ($server, $sock) = @_;

        xprint "$server: Authenticating...\n";
        print $sock 'NICK '.$servers->{$server}->{nick}."\r\n".
                    'USER '.$servers->{$server}->{username}.
                    ' 0 0 :'.$servers->{$server}->{realname}."\r\n";
}

# Handle this event
sub event {
        my ($server, $sock, $data) = @_;

        xprint "$server: $data";
        $conns->{$server}->{lastevent} = time();

        # Event structure
        my $e = {
                servers => $servers,
                conns => $conns,
                mods => $mods,

                server => $server,
                sinfo => $servers->{$server},
                sock => $sock,
                from => undef,
                to => undef,
                dest => undef,
                data => undef,
                raw => undef,
                knick => undef,
                _data => $data, # Unmolested buffer
        };

        chop($data); chop($data);

        # RAW
        if ($data =~ /^:(\S+) (\d+) (\S+) :(.+)/ ||
            $data =~ /^:(\S+) (\d+) \* (\S+) :(.+)/) {
                $e->{from} = $1;
                $e->{raw} = $2;
                $e->{to} = $3;
                $e->{data} = $4;
                event2mods($events->{raw}, $e);
        # SNOTICE
        } elsif ($data =~ /^NOTICE (\S+) :(.+)/) {
                $e->{to} = $1;
                $e->{data} = $2;
                event2mods($events->{snotice}, $e);
        # PRIVMSG
        } elsif ($data =~ /^:(\S+) PRIVMSG (\S+) :(.+)$/) {
                $e->{from} = $1;
                $e->{to} = $2;
                $e->{data} = $3;
                event2mods($events->{privmsg}, $e);

                # Command help (<nick>: help <module>
                if ($e->{data} =~ /^([^:]+):\s*help\s+(.+)/) {
                        if (lc($1) eq $conns->{$server}->{curnick}) {
                                $e->{data} = $2;
                                event2mods($events->{help}, $e, $2);
                        }
                # Command (<nick>: )
                } elsif ($e->{data} =~ /^([^:]+):\s*(.+)/) {
                        if (lc($1) eq $conns->{$server}->{curnick}) {
                                $e->{data} = $2;
                                event2mods($events->{command}, $e);
                        }
                }
        # PING
        } elsif ($data =~ /^PING (.+)/) {
                $e->{data} = $1;
                event2mods($events->{ping}, $e);
        # NOTICE
        } elsif ($data =~ /^:(\S+) NOTICE (\S+) :(.+)/) {
                $e->{from} = $1;
                $e->{to} = $2;
                $e->{data} = $3;
                event2mods($events->{notice}, $e);
        # PART
        } elsif ($data =~ /^:(\S+) PART (\S+)( :(.*))?/) {
                $e->{from} = $1;
                $e->{to} = $2;
                $e->{data} = $4;
                event2mods($events->{part}, $e);
        # JOIN
        } elsif ($data =~ /^:(\S+) JOIN :?(.+)/) {
                $e->{from} = $1;
                $e->{to} = $2;
                event2mods($events->{join}, $e);
        # QUIT
        } elsif ($data =~ /^:(\S+) QUIT :(.+)/) {
                $e->{from} = $1;
                $e->{data} = $2;
                event2mods($events->{quit}, $e);
        # KICK
        } elsif ($data =~ /^:(\S+) KICK (\S+) (\S+) :(.+)/) {
                $e->{from} = $1;
                $e->{to} = $2;
                $e->{knick} = $3;
                $e->{data} = $4;
                event2mods($events->{kick}, $e);
        }
}

# Pass event out to the modules
sub event2mods {
        my ($es, $e, $m) = @_;

        # Resolve 'dest', which will decide whether this was to a channel
        # or a private message
        if ($e->{to} && $e->{from}) {
                if ($e->{to} =~ /^\#.+/) {
                        $e->{dest} = $e->{to};
                } else {
                        $e->{from} =~ /(.+)!.+/;
                        $e->{dest} = $1;
                }
        }

        # If we are specifying a module, we want it to go out to just one
        if ($m) {
                return if (!$mods->{$m});
                return if (!$es->{$m});

                my $f = $mods->{$m}."->".$es->{$m};
                eval "$f(\$e);";
                return;
        }

        # Send out to modules
        foreach (keys(%{$es})) {
                my $f = $mods->{$_}."->".$es->{$_};
                eval "$f(\$e);";
        }
}

# Remove a connection
sub delconn {
        my ($server, $sock) = @_;

        xprint "$server: Removing connection: ";

        if ($sock) {
                $poll->remove($sock);
                $sock->close();
        }

        $conns->{$server}->{enabled} = 0;
        print "success\n";
}

# Launch connection to a server
sub tryconn {
        my $s = shift;

        my $sock;

        # Connection structure
        $conns->{$s} = {
                enabled => 1,
                sock => undef,
                lastevent => undef,
                curnick => $servers->{$s}->{nick},
        };

        xprint "$s: Opening socket: ";

        if ($servers->{$s}->{ssl} =~ /(yes|y|true|t|1)/i) {
                $sock = IO::Socket::SSL->new(
                        PeerAddr => $servers->{$s}->{host},
                        PeerPort => $servers->{$s}->{port},
                        Proto => 'tcp',
                        Blocking => 0
                );
        } else {
                $sock = IO::Socket::INET->new(
                        PeerAddr => $servers->{$s}->{host},
                        PeerPort => $servers->{$s}->{port},
                        Proto => 'tcp',
                        Blocking => 0
                );
        }

        $conns->{$s}->{sock} = $sock;
        $conns->{$s}->{lastevent} = time();

        if (!$sock) {
                print "fail\n";
                return;
        }

        $poll->mask($sock, POLLIN | POLLOUT);
        print "success\n";
}

# Load module
sub loadmod {
        my ($mp, $m) = @_;
        require("$mp/$m.pm");
        return "mods::${m}::${m}";
}

# Unload modules
sub unloadmods {
        xprint "Unloading modules: ";

        foreach (keys(%{$mods})) {
                my $m = $mods->{$_};
                $m->crap();
                eval "undef &".$m."::init;";
                eval "undef &".$m."::crap;";
        }

        $mods = { };
        $events = {
                privmsg => { },
                snotice => { },
                ping => { },
                notice => { },
                part => { },
                join => { },
                quit => { },
                kick => { },
                raw => { },
                command => { },
                help => { },
        };

        foreach (keys(%INC)) {
                if ($_ =~ /^$ap\/mods\//) {
                        delete $INC{$_};
                }
        }

        print "success\n";
}

# Load modules
sub loadmods {
        xprint "Loading modules...\n";

        my @mod_paths = <$ap/mods/*>;
        foreach my $mp (@mod_paths) {
                $mp =~ /\/([^\/]*)$/;
                my $m = $1;

                xprint "  $m: ";

                eval { $mods->{$m} = loadmod($mp, $m); };
                if ($@) {
                        print "fail\n";
                        next;
                }

                my $e = $mods->{$m}->init();
                foreach (keys(%{$e})) {
                        $events->{$_}->{$m} = $e->{$_};
                }

                print "success\n";
        }
}
